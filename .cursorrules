# .cursorrules for Home Edge Firewall Ansible Project

## Project Overview
This is an Ansible automation project for managing a Fortigate firewall configuration.
The project follows a modular approach with roles, playbooks, and supports both full backup/restore and minimal JSON-based configuration.

## Technology Stack
- **Primary**: Ansible with fortinet.fortios collection.
- **Target Platform**: Fortigate firewall via HTTPAPI.
- **Development Environment**: macOS/Ubuntu with pipx-managed Ansible.
- **Version Control**: Git/GitHub.
- **Documentation**: Plain text files and structured directories.

## Architecture Principles

### Playbook Structure
- Each major Fortigate feature has its own numbered playbook (e.g., `07-dns-backup.yml`).
- Three-tier approach per feature:
  1. `XX-feature-backup.yml` - Exports current config.
  1. `XX-feature-create-from-backup.yml` - Restores from full backup.
  1. `XX-feature-create-from-minimal.yml` - Creates from minimal JSON.

### Role-Based Organization
- Each feature has a dedicated role under `roles/`.
- Role tasks are split into:
  - `backup.yml` - Export functionality.
  - `create-from-backup.yml` - Full restore functionality.
  - `create-from-minimal.yml` - Minimal config functionality.
  - `add-entry.yml` or `add-entry-custom.yml`/`add-entry-group.yml` - Core creation logic.

### Data Management
- **Full backups**: `.bkp` files with all Fortigate parameters.
- **Minimal configs**: `.json` files with only UI-visible parameters.
- Organized by feature in `backup/root/` directory structure.

## Code Style & Conventions

### Playbook Standards
```yaml
---
- name: "Descriptive action with feature name"
  hosts: "firewalls"
  gather_facts: false  # ALWAYS false for Fortigate

  tasks:
    - name: "Action description"
      ansible.builtin.include_tasks: "{{ path_role_feature }}/task-file.yml"
```

### Task File Patterns
```yaml
---
- name: "Reading the json file '{{ file.path }}' that contains the desired settings"
  ansible.builtin.set_fact:
    desired_settings: "{{ lookup('file', file.path) | from_json }}"

- name: "Printing the desired settings json object"
  ansible.builtin.debug:
    msg: "{{ desired_settings }}"
  tags: ["never", "debug"]

- name: "Creating/Updating [Feature] entry: {{ desired_settings.name }}"
  fortinet.fortios.fortios_[module_name]:
    vdom: "{{ vdom | default(omit, true) }}"
    state: "present"
    [module_config]:
      name: "{{ desired_settings.name }}"
      required_field: "{{ desired_settings.required_field }}"
      optional_field: "{{ desired_settings.optional_field | default(omit, true) }}"
  register: "output"
```

### Variable Naming
- Use descriptive names with underscores: `desired_settings`, `backup_files`.
- Prefix path variables: `path_role_`, `path_backup_`.
- Use consistent suffixes: `_path`, `_files`, `_extension`.

### Error Handling & Debugging
- Include debug tasks with `tags: ["never", "debug"]`.
- Register outputs as `output` for consistency.
- Use `default(omit, true)` for optional Fortigate parameters.
- Let Fortigate handle validation - don't over-validate in Ansible.

## File Organization Standards

### Directory Structure
```
playbook/
├── [01-99]-*.yml                    # Individual feature playbooks
├── site-*.yml                       # Master playbooks
├── ansible.cfg                      # Ansible configuration
├── roles/
│   └── [feature]/
│       └── tasks/
│           ├── backup.yml
│           ├── create-from-backup.yml
│           ├── create-from-minimal.yml
│           └── add-entry*.yml
├── backup/root/
│   └── [feature]/
│       ├── *.bkp                    # Full backup files
│       ├── *.json                   # Minimal config files
│       ├── custom/                  # For services
│       └── groups/                  # For service groups
└── inventory/
    └── hosts                        # Inventory file
```

### Naming Conventions
- **Playbooks**: `##-feature-action.yml` (zero-padded numbers).
- **Backup files**: `lowercase-name.bkp`.
- **Minimal files**: `lowercase-name.json` (matching .bkp filename).
- **VLAN files**: `###-VL-ENV-ROLE.txt`.

## JSON Structure Standards

### Minimal JSON Requirements
- **Custom Services**: Must include `name`, `category`, `protocol`.
- **Service Groups**: Must include `name`, `member`.
- **DNS**: Must include `name`, `domain`, `type`.
- Only include parameters visible in Fortigate UI.
- Use exact parameter names from corresponding `.bkp` files.

### Optional Parameter Handling
```yaml
# Required parameters - no default
name: "{{ desired_settings.name }}"

# Optional parameters - use omit
optional_param: "{{ desired_settings.optional_param | default(omit, true) }}"

# Handle hyphenated keys from JSON
hyphenated_param: "{{ desired_settings['hyphenated-param'] | default(omit, true) }}"
```

## Network Configuration Standards

### VLAN Scheme
- **Home-Infra**: VLAN IDs 1-99, IP range 10.1.X.X.
- **Homelab**: VLAN IDs 101-199, IP range 10.2.X.X.
- VLAN ID maps to third octet: VLAN 110 → 10.2.110.0/28.
- Standard /28 subnets with .1 as gateway, .2-.14 as DHCP range.

### Inventory Requirements
```ini
[firewalls:vars]
ansible_user=admin
ansible_network_os=fortinet.fortios.fortios
ansible_connection=httpapi
ansible_httpapi_use_ssl=true
vdom=root
```

## Quality Guidelines

### Idempotency
- All playbooks must be safely re-runnable.
- Use `state: present` for create operations.
- Rely on Fortigate's built-in change detection.

### Testing Approach
- Start with low-risk features (services, DNS) before network changes.
- Use backup playbooks before making changes.
- Test minimal JSON with non-critical elements first.

### Documentation Standards
- Maintain text files in `documentation/` matching UI structure.
- Keep README focused on commands and purpose, not verbose explanations.
- Update `copilot-context.md` for major workflow changes.

## Common Patterns to Follow

### File Processing Loop
```yaml
- name: "Retrieving the [type] files"
  ansible.builtin.include_tasks: "{{ path_common_firewall_get_backup_files }}"
  vars:
    paths: "{{ backup_feature_path }}"
    patterns: "{{ backup_files_extension }}"  # or minimal_files_extension

- name: "Creating [Feature] entries from [type]"
  ansible.builtin.include_tasks: "add-entry.yml"
  loop: "{{ backup_files.files | default([]) | sort(attribute='path') }}"
  loop_control:
    loop_var: "file"
    label: "{{ file.path }}"
```

### Module Task Template
```yaml
- name: "Creating [Feature] entry: {{ desired_settings.name }}"
  fortinet.fortios.fortios_[appropriate_module]:
    vdom: "{{ vdom | default(omit, true) }}"
    state: "present"
    [module_section]:
      # Required fields first
      name: "{{ desired_settings.name }}"
      # Optional fields with omit pattern
      optional_field: "{{ desired_settings.optional_field | default(omit, true) }}"
  register: "output"
```

## AI Assistant Instructions

When working with this codebase:

1. **ALWAYS** set `gather_facts: false` for Fortigate playbooks.
1. **NEVER** use pip commands - only pipx or homebrew.
1. **FOLLOW** the three-tier backup/restore pattern for new features.
1. **USE** the exact variable names and patterns shown above.
1. **PRESERVE** the modular role structure.
1. **MATCH** existing file naming conventions exactly.
1. **INCLUDE** debug tasks with proper tags.
1. **USE** `default(omit, true)` for optional Fortigate parameters.
1. **MAINTAIN** the backup/minimal JSON distinction.
1. **KEEP** minimal JSON files small and UI-focused only.

When creating new features, copy the patterns from existing roles like `dns` or `services` rather than inventing new approaches.
